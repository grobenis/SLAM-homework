## 二 图像去畸变

现实生活中的图像总存在畸变。原则上来说，针孔透视相机应该将三维世界中的直线投影成直线，但是当我们使用广角和鱼眼镜头时，由于畸变的原因，直线在图像里看起来是扭曲的。本次作业，你将尝试如何对一张图像去畸变，得到畸变前的图像。

修改过程：

### 代码

```C++
// u(x) 列 v(y) 行
double u_distorted = 0, v_distorted = 0;
// TODO 按照公式，计算点(u,v)对应到畸变图像中的坐标
double x = (u-cx)/fx, y = (v-cy)/fy; //把像素坐标系的点投影到归一化平面
double r = sqrt(x*x+y*y);            // 计算图像点坐标到光心的距离；
// start your code here
// 计算投影点畸变后的点
double x_distorted = x*(1+k1*r+k2*r*r)+2*p1*x*y+p2*(r+2*x*x); //
double y_distorted = y*(1+k1*r+k2*r*r)+2*p2*x*y+p1*(r+2*y*y); //
// 把畸变后的点投影回去
u_distorted = x_distorted*fx+cx;
v_distorted = y_distorted*fy+cy;
// end your code here
```

#### 运行结果截图

![image-20200604223739458](image/去畸变.png)





点云计算代码

```C++
    // TODO 根据双目模型计算点云
    // 如果你的机器慢，请把后面的v++和u++改成v+=2, u+=2
    for (int v = 0; v < left.rows; v++)
        for (int u = 0; u < left.cols; u++) {

            Vector4d point(0, 0, 0, left.at<uchar>(v, u) / 255.0); // 前三维为xyz,第四维为颜色
            // start your code here (~6 lines)
            // 根据双目模型计算 point 的位置
            double x = (u-cx)/fx;
            double y = (v-cy)/fy;
            float disp = disparity.at<uchar>(v,u); //视差
            double depth = fx*d/(disp);//  d是基线
//            cout<<x<<' '<<y<<' '<<z<<endl;
            point[0] = x*depth;
            point[1] = y*depth;
            point[2] = 1*depth;
//            cout<<point<<endl;
            pointcloud.push_back(point);
            // end your code here
        }
```



![image-20200605003041319](/home/guoben/Project/SLAM-homework/ch4/image/点云结果.png)



```cmd
/home/guoben/Project/SLAM-homework/ch4/GaussNewton/bin/GN
total cost: 3.19575e+06
total cost: 376785
total cost: 35673.6
total cost: 2195.01
total cost: 174.853
total cost: 102.78
total cost: 101.937
total cost: 101.937
total cost: 101.937
total cost: 101.937
total cost: 101.937
total cost: 101.937
total cost: 101.937
cost: 101.937, last cost: 101.937
estimated abc = 0.890912, 2.1719, 0.943629

Process finished with exit code 0
```

![image-20200605015118226](image/GN.png)